<!DOCTYPE html>
<meta charset="utf-8">
<head>
    <!-- Load d3.js -->
    <script src="https://d3js.org/d3.v6.js"></script>
    <link rel="stylesheet" type="text/css" href="css/style.css">
  </head>
<h1 class="pageTitle">Spotify Analyze</h1>
<div class="subTitle">
  We collected 100 tracks for each music genre, and analyzed their different audio properties. <br>
  Each audio property is rated from 0 to 1.
</div>
  
<div class="contentContainer">
  <div class="tapStripContainer">
    <div class="selector popSelected" id="popSelector" onclick="tabClick('pop')">
      Pop
    </div>
    <div class="selector classicalSelected" id="classicalSelector" onclick="tabClick('classical')">
      Classical
    </div>
    <div class="selector countryUnselected" id="countrySelector" onclick="tabClick('country')">
      Country
    </div>
    <div class="selector metalUnselected" id="metalSelector" onclick="tabClick('metal')">
      Metal
    </div>
    <div class="selector hiphopUnselected" id="hiphopSelector" onclick="tabClick('hiphop')">
      HipHop
    </div>
    <div class="selector jazzUnselected" id="jazzSelector" onclick="tabClick('jazz')">
      Jazz
    </div>
  </div>
  <div class="graphsContainer">
    <div class="mainViewContainer">
      <div class="webChart"></div>
    </div>
    <div class="sidePanelContainer">
      <div class="detailedViewTitle">
        Detailed View
      </div>
      <div id="sideTitle" class="sideTitle"></div>
      <div id="lineChart"></div>

      <div id="pipeChart" class="pipeChart">
        <!-- Container for graph -->
      </div>
    </div>
  </div>
</div>

<script>

  const genreColorMap = new Map(); // a map keeping track if a genre is selected 
  genreColorMap.set('pop', 'rgb(114, 158, 206)');
  genreColorMap.set('classical', 'rgb(103,191,92)')
  genreColorMap.set('country', 'rgb(140, 86, 75)');    
  genreColorMap.set('metal', 'rgb(162,162,162)')
  genreColorMap.set('hiphop', 'rgb(214,39,40)')
  genreColorMap.set('jazz', 'rgb(173,139,201)')      

  // initializating selected map
  const selectedMap = new Map(); // a map keeping track if a genre is selected 
  selectedMap.set('pop', true);
  selectedMap.set('classical', true)
  selectedMap.set('country', false);    
  selectedMap.set('metal', false)
  selectedMap.set('hiphop', false)
  selectedMap.set('jazz', false)      

  const attributes = ['acousticness','danceability', 'energy', 'instrumentalness','speechiness', 'valence'];
  const selectedAttribute = attributes[2]; // change the content
  displayedGenreInPipe = getSelectedGenres().length == 0 ? "" : getSelectedGenres[0]

  function tabClick(genreName) {
    if (selectedMap.get(genreName)) { // it is already selected
      document.getElementById(genreName+'Selector').classList.remove(genreName+'Selected')
      document.getElementById(genreName+'Selector').classList.add(genreName+'Unselected')
      selectedMap.set(genreName, false);
    } else { // it is unselected
      document.getElementById(genreName+'Selector').classList.remove(genreName+'Unselected')
      document.getElementById(genreName+'Selector').classList.add(genreName+'Selected')
      selectedMap.set(genreName, true);
    }
    getSelectedGenres();
  }

  function getSelectedGenres() {
    selectedGenres =[]
    for (let k of selectedMap.keys()) {
      if (selectedMap.get(k))
      selectedGenres.push(k)
      }
    console.log(selectedGenres);
    return selectedGenres;
  }

  // get the data
  d3.csv("https://raw.githubusercontent.com/6859-sp21/a4-spotifyanalyze/main/data/genre.csv").then(function(sourceData) {
    for (const tab of document.getElementsByClassName("selector")){
      console.log("Here is a selector")
      tab.addEventListener("click",function(){
        d3.select("svg.lineChart").remove();
        if (getSelectedGenres().length === 0) {
          d3.select("svg.pipe").remove();
          return;
        }
        if (displayedGenreInPipe != getSelectedGenres()[0]){
          d3.select("svg.pipe").remove();
        }
        generateLineChart(sourceData,selectedAttribute)
      });
    }
    generateSideTitle(selectedAttribute);
    generateLineChart(sourceData,selectedAttribute)
    generateScatterPlot(sourceData, selectedGenres[0], selectedAttribute)
  });

  function generateSideTitle(selectedAttribute){
    document.getElementById("sideTitle").innerHTML = selectedAttribute;
  }

  function generateLineChart(sourceData, selectedAttribute){ // genres, attribites
    selectedGenres = getSelectedGenres();
    generateScatterPlot(sourceData, selectedGenres[0], selectedAttribute)
    // set the dimensions and margins of the graph
    const margin = {top: 10, right: 10, bottom: 10, left: 50},
        width = 550,
        height = 400;

    // append the svg object to the body of the page
    const svg = d3.select("#lineChart")
      .append("svg")
      .attr("class", "lineChart")
      .attr('width', width)
      .attr('height', height)
      .append("g")

    // Scale and axis
    const x = d3.scaleLinear()
        .domain([0,1])
        .range([margin.left, width-margin.right]);

    // a tick free y-axis
    svg.append('line')
    .style("stroke", "black")
    .style("stroke-width", 2)
    .attr("x1", margin.left)
    .attr("y1", height-margin.bottom+10)
    .attr("x2", width-margin.right)
    .attr("y2", height-margin.bottom+10); 

    var y = d3.scaleLinear()
              .range([height-margin.bottom, margin.top])
              .domain([0, 10]);
  
    // Compute kernel density estimation
    var kde = kernelDensityEstimator(kernelEpanechnikov(0.1), x.ticks(10))
    for (const selectedGenre of selectedGenres){
      const density1 =  kde( sourceData
        .filter(function(d){ return d.genre === selectedGenre} )
        .map(function(d){ return d[selectedAttribute]; }) )

      svg.append("path")
        .datum(density1)
        .attr('class', 'individualLine')
        .attr('class', selectedGenre+'Line')
        .attr("fill", "none")
        .attr("stroke", genreColorMap.get(selectedGenre))
        .attr("stroke-width", 3.5)
        .attr("opacity", ".85")
        .attr("d", d3.line()
          .x(function(d) { return x(d[0]) })
          .y(function(d) { return y(d[1]) })
          .curve(d3.curveMonotoneX) 
        );

        // Draw fake lines to increase clickable area
        svg.append("path")
        .datum(density1)
        .attr("fill", "none")
        .attr("stroke", "red")
        .attr("stroke-width", 25)
        .attr("opacity", ".0")
        .attr("d", d3.line()
          .x(function(d) { return x(d[0]) })
          .y(function(d) { return y(d[1]) })
          .curve(d3.curveMonotoneX) 
          )
        .on("click", function(d) {
          if (displayedGenreInPipe != selectedGenre){
            d3.select("path."+displayedGenreInPipe +'Line').attr("stroke-width", 3.5)
              .attr("opacity", ".8");
            d3.select("path."+selectedGenre+'Line').attr("stroke-width", 4.5)
              .attr("opacity", "1");
            generateScatterPlot(sourceData, selectedGenre, selectedAttribute)
          }
        });
    }
    d3.select("path."+displayedGenreInPipe+'Line').attr("stroke-width", 4.5)
              .attr("opacity", "1");
  }

  // Function to compute density
  function kernelDensityEstimator(kernel, X) {
    return function(V) {
      return X.map(function(x) {
        return [x, d3.mean(V, function(v) { return kernel(x - v); })];
      });
    };
  }
  function kernelEpanechnikov(k) {
    return function(v) {
      return Math.abs(v /= k) <= 1 ? 0.75 * (1 - v * v) / k : 0;
    };
  }

  function generateScatterPlot(sourceData, selectedGenre, selectedAttribute) {
    if (displayedGenreInPipe == selectedGenre){return;}
    d3.select("svg.pipe").remove();
    // Get a subset of the data based on the group
    const filteredData = sourceData.filter(function(d){
      return d.genre === selectedGenre;
    })
    console.log(selectedGenre)

    var margin = {top: 20, right: 10, bottom: 45, left: 50},
      width = 550, // actual width and height
      height = 150;

    const svg = d3.create('svg')
    .attr('width', width)
    .attr('height', height)
    .attr('class', "pipe");

    // scales setup
    const xScale = d3.scaleLinear()
    .domain([0, 1]) // questionable setup ?? 
    .range([margin.left, width-margin.right]);
    const yScale = d3.scaleLinear()
    .domain([0, 1])
    .range([height - margin.bottom, margin.top]);

    // drawing SVG
    const symbol = d3.symbol();
    svg.append('g')
      .selectAll('circle') // d3-shape functions (like d3.symbol) generate attributes for SVG <path> elements
      .data(filteredData)
      .join('circle')
      .attr('transform', d => `translate(${xScale(d[selectedAttribute])}, ${yScale(Math.random()*0.95+0.05)})`) // leave a bit space between plot and axis
      .attr('d', d => symbol()) // output of the d3.symbol is wired up to the "d
      .attr('fill-opacity','0.7')
      .attr('fill', genreColorMap.get(selectedGenre))  // inpute color scale 
      .attr('r','3');

    // add in label 
    svg.append('g').append("text")
    .text("100 " + selectedGenre +" songs")
    .attr('x', 10)
    .attr('y', 10)
    .attr('fill', genreColorMap.get(selectedGenre))


    //6. Drawing our x-axis
    svg.append('g')
      .attr('transform', `translate(0, ${height - margin.bottom})`)
      .call(d3.axisBottom(xScale).ticks(10))

    // axis label
    svg.append('g')
    .attr('class', 'pipeAxisLabel')
    .append("text")
    .text(selectedAttribute)
    .attr('x', '50%')
    .attr('y', height-10)
     
    displayedGenreInPipe = selectedGenre;
    // setting up 
    document.getElementById("pipeChart").appendChild(svg.node());
  }

</script>
