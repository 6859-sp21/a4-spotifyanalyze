<html>
  <head>
    <!-- Load d3.js -->
    <script src="https://d3js.org/d3.v6.js"></script>
    <link rel="stylesheet" type="text/css" href="css/style.css">
  </head>
  <body>
    <h1 class="pageTitle">Spotify Analyze</h1>
    <div id="chart" class="pageContainer">
      <!-- Container for graph -->
    </div>

    <script>
      /*
      // Data
      const test = d3.csv("./data/genre-agg.csv");
      console.log(test);
      
      // tutorial: https://yangdanny97.github.io/blog/2019/03/01/D3-Spider-Chart
      let data = [];
      // let features = ["A","B","C","D","E","F"];
      let features = ["danceability", "energy", "speechiness", "acousticness", "instrumentalness", "valence"];
      //generate the data
      for (var i = 0; i < 3; i++){
          var point = {}
          //each feature will be a random number from 1-9
          features.forEach(f => point[f] = 1 + Math.random() * 8);
          data.push(point);
      }
      console.log(data);

      let svg = d3.select("body").append("svg")
                  .attr("width", 800)
                  .attr("height", 800);

      // plot gridline circles and ticks
      let radialScale = d3.scaleLinear()
          .domain([0,10])
          .range([0,250]);
      let ticks = [2,4,6,8,10];

      ticks.forEach(t =>
        svg.append("circle")
        .attr("cx", 300)
        .attr("cy", 300)
        .attr("fill", "none")
        .attr("stroke", "gray")
        .attr("r", radialScale(t))
      );

      ticks.forEach(t =>
        svg.append("text")
        .attr("x", 305)
        .attr("y", 300 - radialScale(t))
        .text(t.toString())
      );

      function angleToCoordinate(angle, value){
          let x = Math.cos(angle) * radialScale(value);
          let y = Math.sin(angle) * radialScale(value);
          return {"x": 300 + x, "y": 300 - y};
      }

      // plot six axes 
      for (var i = 0; i < features.length; i++) {
        let ft_name = features[i];
        let angle = (Math.PI / 2) + (2 * Math.PI * i / features.length);
        let line_coordinate = angleToCoordinate(angle, 10);
        let label_coordinate = angleToCoordinate(angle, 10.5);

        //draw axis line
        svg.append("line")
        .attr("x1", 300)
        .attr("y1", 300)
        .attr("x2", line_coordinate.x)
        .attr("y2", line_coordinate.y)
        .attr("stroke","black");

        //draw axis label
        svg.append("text")
        .attr("x", label_coordinate.x)
        .attr("y", label_coordinate.y)
        .text(ft_name);
      }
      
      // plot data
      let line = d3.line()
          .x(d => d.x)
          .y(d => d.y);
      let colors = ["darkorange", "gray", "navy"];

      // helper function iterates thru fields in each data point in order, calculate coordinate for attribute
      function getPathCoordinates(data_point){
        let coordinates = [];
        for (var i = 0; i < features.length; i++){
          let ft_name = features[i];
          let angle = (Math.PI / 2) + (2 * Math.PI * i / features.length);
          coordinates.push(angleToCoordinate(angle, data_point[ft_name]));
        }
        return coordinates;
      }

      // append path element to draw continuous line between coordiantes in d attribute
      for (var i = 0; i < data.length; i ++){
        let d = data[i];
        let color = colors[i];
        let coordinates = getPathCoordinates(d);

        //draw the path element
        svg.append("path")
        .datum(coordinates)
        .attr("d",line)
        .attr("stroke-width", 3)
        .attr("stroke", color)
        .attr("fill", color)
        .attr("stroke-opacity", 1)
        .attr("opacity", 0.5);
      }
      */
      
      d3.csv("data/genre-agg.csv", function(d) {
        return {
          danceability: 10*+d.danceability,
          energy: 10*+d.energy, 
          speechiness: 10*+d.speechiness, 
          acousticness: 10*+d.acousticness, 
          instrumentalness: 10*+d.instrumentalness, 
          valence: 10*+d.valence,
          genre: d.genre
        }
      }).then(function(data) {
        console.log(data);


        let features = ["danceability", "energy", "speechiness", "acousticness", "instrumentalness", "valence"];

        let svg = d3.select("body").append("svg")
                    .attr("width", 800)
                    .attr("height", 800);

        // plot gridline circles and ticks
        let radialScale = d3.scaleLinear()
            .domain([0,10])
            .range([0,250]);
        let ticks = [2,4,6,8,10];

        ticks.forEach(t =>
          svg.append("circle")
          .attr("cx", 300)
          .attr("cy", 300)
          .attr("fill", "none")
          .attr("stroke", "gray")
          .attr("r", radialScale(t))
        );

        ticks.forEach(t =>
          svg.append("text")
          .attr("x", 305)
          .attr("y", 300 - radialScale(t))
          .text(t.toString())
        );

        function angleToCoordinate(angle, value){
            let x = Math.cos(angle) * radialScale(value);
            let y = Math.sin(angle) * radialScale(value);
            return {"x": 300 + x, "y": 300 - y};
        }

        // plot six axes 
        for (var i = 0; i < features.length; i++) {
          let ft_name = features[i];
          let angle = (Math.PI / 2) + (2 * Math.PI * i / features.length);
          let line_coordinate = angleToCoordinate(angle, 10);
          let label_coordinate = angleToCoordinate(angle, 10.5);

          //draw axis line
          svg.append("line")
          .attr("x1", 300)
          .attr("y1", 300)
          .attr("x2", line_coordinate.x)
          .attr("y2", line_coordinate.y)
          .attr("stroke","black");

          //draw axis label
          svg.append("text")
          .attr("x", label_coordinate.x)
          .attr("y", label_coordinate.y)
          .text(ft_name);
        }
        
        // plot data
        let line = d3.line()
            .x(d => d.x)
            .y(d => d.y);
        // let colors = ["darkorange", "gray", "navy"];
        let colors = ["red","orange","yellow","green","blue","purple"];

        // helper function iterates thru fields in each data point in order, calculate coordinate for attribute
        function getPathCoordinates(data_point){
          let coordinates = [];
          for (var i = 0; i < features.length; i++){
            let ft_name = features[i];
            let angle = (Math.PI / 2) + (2 * Math.PI * i / features.length);
            coordinates.push(angleToCoordinate(angle, data_point[ft_name]));
          }
          return coordinates;
        }

        // append path element to draw continuous line between coordinates in d attribute
        for (var i = 0; i < data.length; i ++){
          let d = data[i];
          let color = colors[i];
          let coordinates = getPathCoordinates(d);

          //draw the path element
          svg.append("path")
          .datum(coordinates)
          .attr("d",line)
          .attr("stroke-width", 3)
          .attr("stroke", color)
          .attr("fill", color)
          .attr("stroke-opacity", 1)
          .attr("opacity", 0.5);
        }
      });


      // insert svg

      // Should always be present to let svg give back our visualization
      document.getElementById("chart").appendChild(svg.node());
    </script>
  </body>
</html>